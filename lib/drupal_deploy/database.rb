require 'capistrano'
require 'drupal_deploy/error'
require 'drupal_deploy/configuration'
require 'yaml'
require 'php_serialize'

module DrupalDeploy
  class Database
    class Error < DrupalDeploy::Error; end


    STANDARD_KEYS = %w(driver database username password host port prefix collation).map &:to_sym
    MANAGE_KEYS   = %w(driver database username password host port prefix 
                       admin_username admin_password).map &:to_sym
  
    def initialize(config)
      @config = config
      @seen_paths = {}
    end

    def method_missing(sym, *args, &block)
      if @config.respond_to?(sym)
        @config.send(sym, *args, &block)
      else
        super
      end
    end

    def configure
      databases_path.find do |val|
        set :databases, load_path( val, databases )
        MANAGE_KEYS.all? {|k| databases.key? k}
      end
    end

    def load_path(path,databases = {})
      unless @seen_paths[path]
        logger.info "Trying to load database setting from #{path.inspect}"
        if path !~ /^[\/~]/
          path = latest_release+"/"+path
        end
        if path =~ /.php$/
          @seen_paths[path] = load_php_path path
        elsif path =~ /.yml$/
          @seen_paths[path] = load_yml_path path
        else
          throw Error.new "Unknown file type: #{path}"
        end
      end
      deep_merge(@seen_paths[path],databases)
    end

    def load_php_path(path)
      prefix = ''
      if path.sub!(/^~/,'')
        prefix = "getenv('HOME')." 
      end

      script = <<-END.gsub(/^ */,'')
        <?php
        $filename = #{prefix}'#{path}';
        if( file_exists($filename) ) {
          require_once($filename);
          if( isset($databases) ) {
            print serialize($databases);
          }
        } 
      END
      put script, '/tmp/load_db_credentials.php', :once => true
      resp = capture "#{drush_bin} php-script /tmp/load_db_credentials.php"
      
      settings = {}
      unless resp.empty?
        resp = DrupalDeploy::Configuration.unserialize_php(resp)
        if resp != []
          settings = resp
        end
      end
      settings
    end

    def load_yml_path(path)
      prefix = ''
      if path.sub!(/^~/,'')
        prefix = '"$HOME"'
      end

      yaml =  capture("[ ! -e #{prefix}'#{path}' ] || cat #{prefix}'#{path}'")
      if yaml.empty?
        {}
      else
        credentials = YAML.load yaml
        DrupalDeploy::Configuration.normalize_value(credentials)
      end
    end

    def update_settings(settings,template = 'sites/default/default.settings.php')
      if template !~ /^[\/~]/
        template = latest_release+"/"+template
      end
      prefix = ''
      if template.sub!(/^~/,'')
        prefix = "getenv('HOME')." 
      end
      script = <<-END.gsub(/^ */,'')
        <?php
        define('DRUPAL_ROOT', '#{latest_release}');
        define('MAINTENANCE_MODE', 'install');

        $template = #{prefix}'#{template}';
        $default = DRUPAL_ROOT.'/sites/default/default.settings.php';
        $backup = '/tmp/default_settings_backup.php';

        $databases = unserialize('#{PHP.serialize(settings)}');
        $settings["databases"] = array( 'comment' => 'Generated by drupal-deploy',
                                        'value' => $databases );

        require_once(DRUPAL_ROOT.'/includes/bootstrap.inc');
        require_once(DRUPAL_ROOT.'/includes/install.inc');

        $backed_up = false;
        if ($template != $default && file_exists($default)) {
          rename($default,$backup);
          $backed_up = true;
        }
        rename($template,$default);
        drupal_rewrite_settings($settings);
        if ($backed_up) {
          rename($backup,$default);
        }
      END
      put script, '/tmp/update_settings.php'
      run "#{drush_bin} php-script /tmp/update_settings.php"
    end

    def copy_database(conf,from,to)
      conf = conf.merge(:database => from)
      put (db_tables_query % conf), '/tmp/tables_query.sql'
      tables = capture(%Q{cd #{current_release} && #{drush_bin} sql-cli < /tmp/tables_query.sql})
      tables = tables.split(/\n/)

      sql = <<-END
        CREATE DATABASE #{to};
      END

      tables.each do |table|
        sql += <<-END 
          CREATE TABLE #{to}.#{table} LIKE #{from}.#{table};
          INSERT INTO #{to}.#{table} SELECT * FROM #{from}.#{table};
        END
      end
      put sql, '/tmp/backup_database.sql'
      run %Q{cd '#{current_release}' && #{drush_bin} sql-cli < /tmp/backup_database.sql}, :once => true
    end

    def rename_database(from,to)
      sql = "ALTER TABLE #{from} RENAME TO #{to};"
      put sql, '/tmp/rename_database.sql'
      run %Q{cd '#{current_release}' && #{drush_bin} sql-cli < /tmp/rename_database.sql}
    end

    def drop_database(db)
      sql = "DROP DATABASE #{db};"
      put sql, '/tmp/drop_database.sql'
      run %Q{cd '#{current_release}' && #{drush_bin} sql-cli < /tmp/drop_database.sql}
    end

    # Should split these out
    def deep_update(h1,h2)
      h1.inject({}) do |h,(k,v)|
        if Hash === v && Hash === h2[k]
          h[k] = deep_update(v,h2[k])
        else
          h[k] = h2.key?(k) ? h2[k] : v
        end
        h
      end
    end

    def deep_merge(h1,h2)
      merger = proc { |key,v1,v2| Hash === v1 && Hash === v2 ? v1.merge(v2, &merger) : v2 }
      h1.merge(h2, &merger)
    end

    def each_db(databases)
      databases.each do |site_name,site|
        site.each do |db_name,db|
          yield db,site_name,db_name
        end
      end
    end

    def to_db_url(db)
      "#{db[:driver]}://#{db[:username]}:#{db[:password]}@#{db[:host]}:#{db[:port]}/#{db[:database]}"
    end
  end
end
